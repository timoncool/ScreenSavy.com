<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Improved RGB Lava Lamp Screensaver</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
    }
    .wrap {
      overflow: hidden;
      position: relative;
      height: 100vh;
      background-color: #000;
    }
    canvas {
      width: 100%;
      height: 100%;
      filter: blur(3px);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="bubble"></canvas>
  </div>

  <script>
    ;(function() {
      "use strict";

      var lavaLamps = [];
      var colorCycles = [];

      var ge1doot = {
        screen: {
          elem:     null,
          callback: null,
          ctx:      null,
          width:    0,
          height:   0,
          left:     0,
          top:      0,
          init: function (id, callback, initRes) {
            this.elem = document.getElementById(id);
            this.callback = callback || null;
            if (this.elem.tagName == "CANVAS") this.ctx = this.elem.getContext("2d");
            window.addEventListener('resize', function () {
              this.resize();
            }.bind(this), false);
            this.elem.onselectstart = function () { return false; }
            this.elem.ondrag        = function () { return false; }
            initRes && this.resize();
            return this;
          },
          resize: function () {
            var o = this.elem;
            this.width  = o.offsetWidth;
            this.height = o.offsetHeight;
            for (this.left = 0, this.top = 0; o != null; o = o.offsetParent) {
              this.left += o.offsetLeft;
              this.top  += o.offsetTop;
            }
            if (this.ctx) {
              this.elem.width  = this.width;
              this.elem.height = this.height;
            }
            this.callback && this.callback();
          }
        }
      }

      // Color utility functions
      function hslToRgb(h, s, l) {
        var r, g, b;
        if (s == 0) {
          r = g = b = l;
        } else {
          function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          }
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
      }

      function rgbToHex(r, g, b) {
        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
      }

      // Color cycle class
      var ColorCycle = function(h, s, l, speed) {
        this.h = h;
        this.s = s;
        this.l = l;
        this.speed = speed;
      };

      ColorCycle.prototype.update = function(dt) {
        this.h += this.speed * dt;
        if (this.h > 1) this.h -= 1;
        if (this.h < 0) this.h += 1;
      };

      ColorCycle.prototype.getColor = function() {
        var rgb = hslToRgb(this.h, this.s, this.l);
        return rgbToHex(rgb[0], rgb[1], rgb[2]);
      };

      // Point constructor
      var Point = function(x, y) {
        this.x = x;
        this.y = y;
        this.magnitude = x * x + y * y;
        this.computed = 0;
        this.force = 0;
      };

      Point.prototype.add = function(p) {
        return new Point(this.x + p.x, this.y + p.y);
      };

      // Ball constructor with scaled speed and size
      var Ball = function(parent) {
        var min = .1;
        var max = 1.5;
        var scale = parent.wh / 1080; // Scale relative to Full HD
        this.vel = new Point(
          (Math.random() > 0.5 ? 1 : -1) * (0.05 + Math.random() * 0.1) * scale,
          (Math.random() > 0.5 ? 1 : -1) * (0.05 + Math.random() * 0.1) * scale
        );
        this.pos = new Point(
          parent.width * 0.2 + Math.random() * parent.width * 0.6,
          parent.height * 0.2 + Math.random() * parent.height * 0.6
        );
        this.size = (parent.wh / 15) * scale + (Math.random() * (max - min) + min) * (parent.wh / 15) * scale;
        this.width = parent.width;
        this.height = parent.height;
      };

      // Move balls
      Ball.prototype.move = function() {
        if (this.pos.x >= this.width - this.size) {
          if (this.vel.x > 0) this.vel.x = -this.vel.x;
          this.pos.x = this.width - this.size;
        } else if (this.pos.x <= this.size) {
          if (this.vel.x < 0) this.vel.x = -this.vel.x;
          this.pos.x = this.size;
        }

        if (this.pos.y >= this.height - this.size) {
          if (this.vel.y > 0) this.vel.y = -this.vel.y;
          this.pos.y = this.height - this.size;
        } else if (this.pos.y <= this.size) {
          if (this.vel.y < 0) this.vel.y = -this.vel.y;
          this.pos.y = this.size;
        }

        this.pos = this.pos.add(this.vel);
      };

      // LavaLamp constructor with adaptive grid step
      var LavaLamp = function(width, height, numBalls, colorTop, colorBottom) {
        this.step = Math.floor(Math.min(width, height) / 100); // Adaptive grid step
        this.width = width;
        this.height = height;
        this.wh = Math.min(width, height);
        this.sx = Math.floor(this.width / this.step);
        this.sy = Math.floor(this.height / this.step);
        this.paint = false;
        this.colorTop = colorTop;
        this.colorBottom = colorBottom;
        this.plx = [0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0];
        this.ply = [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1];
        this.mscases = [0, 3, 0, 3, 1, 3, 0, 3, 2, 2, 0, 2, 1, 1, 0];
        this.ix = [1, 0, -1, 0, 0, 1, 0, -1, -1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1];
        this.grid = [];
        this.balls = [];
        this.iter = 0;
        this.sign = 1;

        for (var i = 0; i < (this.sx + 2) * (this.sy + 2); i++) {
          this.grid[i] = new Point(
            (i % (this.sx + 2)) * this.step, (Math.floor(i / (this.sx + 2))) * this.step
          )
        }

        for (var k = 0; k < numBalls; k++) {
          this.balls[k] = new Ball(this);
        }
      };

      // Compute force
      LavaLamp.prototype.computeForce = function(x, y, idx) {
        var force;
        var id = idx || x + y * (this.sx + 2);

        if (x === 0 || y === 0 || x === this.sx || y === this.sy) {
          force = 0.6 * this.sign;
        } else {
          force = 0;
          var cell = this.grid[id];
          var i = 0;
          var ball;
          while (ball = this.balls[i++]) {
            force += ball.size * ball.size / (-2 * cell.x * ball.pos.x - 2 * cell.y * ball.pos.y + ball.pos.magnitude + cell.magnitude);
          }
          force *= this.sign
        }
        this.grid[id].force = force;
        return force;
      };

      // Marching squares
      LavaLamp.prototype.marchingSquares = function(next) {
        var x = next[0];
        var y = next[1];
        var pdir = next[2];
        var id = x + y * (this.sx + 2);
        if (this.grid[id].computed === this.iter) {
          return false;
        }
        var dir, mscase = 0;

        for (var i = 0; i < 4; i++) {
          var idn = (x + this.ix[i + 12]) + (y + this.ix[i + 16]) * (this.sx + 2);
          var force = this.grid[idn].force;
          if ((force > 0 && this.sign < 0) || (force < 0 && this.sign > 0) || !force) {
            force = this.computeForce(
              x + this.ix[i + 12],
              y + this.ix[i + 16],
              idn
            );
          }
          if (Math.abs(force) > 1) mscase += Math.pow(2, i);
        }
        if (mscase === 15) {
          return [x, y - 1, false];
        } else {
          if (mscase === 5) dir = (pdir === 2) ? 3 : 1;
          else if (mscase === 10) dir = (pdir === 3) ? 0 : 2;
          else {
            dir = this.mscases[mscase];
            this.grid[id].computed = this.iter;
          }
          var ix = this.step / (
              Math.abs(Math.abs(this.grid[(x + this.plx[4 * dir + 2]) + (y + this.ply[4 * dir + 2]) * (this.sx + 2)].force) - 1) /
              Math.abs(Math.abs(this.grid[(x + this.plx[4 * dir + 3]) + (y + this.ply[4 * dir + 3]) * (this.sx + 2)].force) - 1) + 1
            );
          ctx.lineTo(
            this.grid[(x + this.plx[4 * dir]) + (y + this.ply[4 * dir]) * (this.sx + 2)].x + this.ix[dir] * ix,
            this.grid[(x + this.plx[4 * dir + 1]) + (y + this.ply[4 * dir + 1]) * (this.sx + 2)].y + this.ix[dir + 4] * ix
          );
          this.paint = true;
          return [
            x + this.ix[dir + 4],
            y + this.ix[dir + 8],
            dir
          ];
        }
      };

      // Render metaballs with vertical gradient and enhanced effects
      LavaLamp.prototype.renderMetaballs = function() {
        var i = 0, ball;
        while (ball = this.balls[i++]) ball.move();
        this.iter++;
        this.sign = -this.sign;
        this.paint = false;
        
        // Создаем вертикальный градиент для всего метаболла
        var gradient = ctx.createLinearGradient(0, 0, 0, this.height);
        gradient.addColorStop(0, this.colorTop);
        gradient.addColorStop(1, this.colorBottom);
        
        // Устанавливаем стиль заливки
        ctx.fillStyle = gradient;
        
        // Добавляем эффект тени для внутреннего свечения
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.colorBottom;
        
        // Устанавливаем режим наложения для более ярких цветов
        ctx.globalCompositeOperation = "lighter";
        
        // Обрабатываем каждый метаболл
        i = 0;
        while (ball = this.balls[i++]) {
          ctx.beginPath();
          var next = [
            Math.round(ball.pos.x / this.step),
            Math.round(ball.pos.y / this.step), false
          ];
          do {
            next = this.marchingSquares(next);
          } while (next);
          if (this.paint) {
            ctx.fill();
            ctx.closePath();
            this.paint = false;
          }
        }
        
        // Возвращаем стандартный режим наложения
        ctx.globalCompositeOperation = "source-over";
      };

      // Main loop with motion blur
      var lastTime = 0;
      var run = function(time) {
        var dt = (time - lastTime) / 1000;
        lastTime = time;

        requestAnimationFrame(run);
        
        // Применяем эффект motion blur для плавности движения
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, screen.width, screen.height);

        for (var i = 0; i < colorCycles.length; i++) {
          colorCycles[i].update(dt);
        }

        for (var i = 0; i < lavaLamps.length; i++) {
          var lamp = lavaLamps[i];
          lamp.colorTop = colorCycles[0].getColor();
          lamp.colorBottom = colorCycles[1].getColor();
          lamp.renderMetaballs();
        }
      };

      // Canvas initialization
      var screen = ge1doot.screen.init("bubble", null, true),
          ctx = screen.ctx;
      screen.resize();

      // Create color cycles with good values for RGB transitions
      colorCycles.push(new ColorCycle(0.6, 0.9, 0.5, 0.01)); // Cool colors (blue/purple/cyan)
      colorCycles.push(new ColorCycle(0.0, 0.9, 0.5, 0.02)); // Warm colors (red/orange/yellow)

      // Create LavaLamp with dynamic number of balls for 4K support
      var numBalls = Math.min(15, Math.max(8, Math.floor(screen.width * screen.height / 1000000)));
      lavaLamps.push(new LavaLamp(screen.width, screen.height, numBalls, "#0000FF", "#FF0000"));

      // Start animation
      requestAnimationFrame(run);
    })();
  </script>
</body>
</html>
