<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Retrowave Voyager - Celestial Edition</title>
    <style>
        :root {
            --bg: #01000a;
            --text: #cccccc;
            --highlight: #ff00ff;
            --panel-border: rgba(255, 0, 255, 0.3);
        }
        body { margin: 0; background-color: var(--bg); color: var(--text); font-family: monospace; overflow: hidden; }
        
        .dg.ac { opacity: 0.15; transition: opacity 0.3s ease; }
        .dg.ac:hover { opacity: 1; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script>
        //--- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ---
        let scene, camera, renderer, controls, composer, clock;
        let car, sun, road, palmGroup, mountainGroup, stars, sceneryGroup;
        let houseMaterials = [];
        let cactusMaterial;
        let vizInitialized = false, analyserL, analyserR, frequencyDataL, frequencyDataR;
        let activeStream = null; // НОВОЕ: Храним активный аудиопоток

        const PALM_COUNT = 16;
        const SCENERY_OBJECT_COUNT = 16;
        const PALM_RANGE = 250;
        const LANE_POSITIONS = [-4.5, -1.5, 1.5, 4.5];
        const MOUNTAIN_W_SEGMENTS = 64;
        const MOUNTAIN_H_SEGMENTS = 20;

        let lastBass = 0;
        let targetLaneX = LANE_POSITIONS[1];
        let isBlinking = false;
        let blinkTimer = 0;

        let currentSpeed, targetSpeed;
        let adaptiveBaseSpeed; 
        let boostState = 'normal';
        let boostEnergy = 0;
        let stateTimer = 0;
        let carZOffset = 0;

        let bassBuffer = []; 
        const BASS_BUFFER_SIZE = 30;
        let energyBuffer = [];
        const ENERGY_BUFFER_SIZE = 120;

        const Viz = {
            minSpeed: 30, speedReactivity: 50, mountainHeight: 40, palmGlow: 1.1, 
            interiorGlowMultiplier: 0.1, carBob: 0.045, headlightIntensity: 6,
            sunPulse: 1.2, laneChangeThreshold: 0.06, laneChangeSpeed: 1, 
            bloomStrength: 0.9, bloomThreshold: 0, bloomRadius: 0.14,
            boostThreshold: 0.7, boostMultiplier: 1.8, boostDuration: 7.9, cooldownDuration: 6,
            boostCarOffset: 3, brakeLightIntensity: 7.7, bassSustainThreshold: 0.4, energyDecayRate: 0.35,
        };
        const gui = new dat.GUI();
        gui.add(Viz, 'minSpeed', 5, 60).name('Min Speed');
        gui.add(Viz, 'speedReactivity', 0, 150).name('Speed Reactivity');
        gui.add(Viz, 'mountainHeight', 5, 50).name('Mountain Height');
        gui.add(Viz, 'palmGlow', 0, 10).name('Palm Glow');
        gui.add(Viz, 'interiorGlowMultiplier', 0, 2.0).name('Interior Glow');
        gui.add(Viz, 'carBob', 0, 0.2).name('Car Bob');
        gui.add(Viz, 'headlightIntensity', 0, 10).name('Headlights');
        gui.add(Viz, 'sunPulse', 0, 5).name('Sun Pulse');
        const drivingFolder = gui.addFolder('Lane Changing');
        drivingFolder.add(Viz, 'laneChangeThreshold', 0.05, 0.3).name('Change Threshold');
        drivingFolder.add(Viz, 'laneChangeSpeed', 1, 10).name('Change Speed');
        const boostFolder = gui.addFolder('Acceleration');
        boostFolder.add(Viz, 'boostThreshold', 0.1, 1.0).name('Boost Energy');
        boostFolder.add(Viz, 'bassSustainThreshold', 0.1, 0.9).name('Sustained Bass');
        boostFolder.add(Viz, 'energyDecayRate', 0.1, 1.0).name('Energy Decay');
        boostFolder.add(Viz, 'boostMultiplier', 1.1, 3.0).name('Speed Multiplier');
        boostFolder.add(Viz, 'boostCarOffset', 0, 10).name('Boost Car Offset');
        boostFolder.add(Viz, 'boostDuration', 1, 10).name('Boost Duration (s)');
        boostFolder.add(Viz, 'cooldownDuration', 1, 10).name('Cooldown (s)');
        boostFolder.add(Viz, 'brakeLightIntensity', 1, 10).name('Brake Light Power');
        const bloomFolder = gui.addFolder('Bloom');
        bloomFolder.add(Viz, 'bloomStrength', 0, 3).name('Strength').onChange(v => composer.passes[1].strength = v);
        bloomFolder.add(Viz, 'bloomThreshold', 0, 1).name('Threshold').onChange(v => composer.passes[1].threshold = v);
        bloomFolder.add(Viz, 'bloomRadius', 0, 2).name('Radius').onChange(v => composer.passes[1].radius = v);
        gui.close();

        //--- ИНИЦИАЛИЗАЦИЯ (сцена, рендерер и т.д.)---
        // ... (весь код init, buildScene, animate, и другие функции без изменений) ...
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            clock = new THREE.Clock();
            const fogColor = new THREE.Color(0x01000a);
            scene.background = fogColor;
            scene.fog = new THREE.Fog(fogColor, 60, 280);
            camera.position.set(0, 5, 9);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1.5, 0);
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), Viz.bloomStrength, Viz.bloomRadius, Viz.bloomThreshold);
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            adaptiveBaseSpeed = Viz.minSpeed;
            currentSpeed = Viz.minSpeed;
            targetSpeed = Viz.minSpeed;
            buildScene();
            setupUI(); // НОВОЕ: Запускаем настройку UI
            animate();
        }
        function buildScene() { setupLighting(); createStars(); createRoad(); createSun(); createMountains(); prepareSceneryMaterials(); createRoadsideScenery(); createProceduralPalms(); createCar(); }
        function setupLighting() { scene.add(new THREE.HemisphereLight(0x00aaff, 0x6a00ff, 0.8)); scene.add(new THREE.AmbientLight(0xffffff, 0.2)); const directionalLight1 = new THREE.DirectionalLight(0x5a2a88, 0.5); directionalLight1.position.set(5, 15, -10); scene.add(directionalLight1); const directionalLight2 = new THREE.DirectionalLight(0x00aaff, 0.3); directionalLight2.position.set(-8, 10, -5); scene.add(directionalLight2); }
        function createStars() { const starCount = 5000; const starVertices = []; for (let i = 0; i < starCount; i++) { const x = THREE.Math.randFloatSpread(2000); const y = THREE.Math.randFloat(10, 500); const z = THREE.Math.randFloatSpread(2000); starVertices.push(x, y, z); } const starGeometry = new THREE.BufferGeometry(); starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3)); const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7, fog: false, transparent: true, opacity: 1.0 }); stars = new THREE.Points(starGeometry, starMaterial); scene.add(stars); }
        function createRoad() { const roadSurfaceMat = new THREE.MeshStandardMaterial({color: 0x080808, roughness: 0.6, metalness: 0.4}); scene.add(new THREE.Mesh(new THREE.PlaneGeometry(30, PALM_RANGE * 2), roadSurfaceMat).rotateX(-Math.PI/2)); const roadGridMat = new THREE.ShaderMaterial({ uniforms: { uColor: { value: new THREE.Color(0x00ffff) }, uGlow: { value: 1.0 }, uTime: { value: 0.0 }, uSpeed: { value: Viz.minSpeed } }, vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`, fragmentShader: `
                    uniform vec3 uColor; uniform float uGlow; uniform float uTime; uniform float uSpeed; varying vec2 vUv;
                    void main() {
                        float p_fade = pow(1.0 - vUv.y, 2.0); float cX = abs(vUv.x - 0.5);
                        float side = smoothstep(0.39, 0.40, cX);
                        float movement = fract(vUv.y * 15.0 + uTime * uSpeed * 0.015);
                        float center_line_mask = 1.0 - smoothstep(0.005, 0.01, cX);
                        float dashes = smoothstep(0.5, 0.51, movement) - smoothstep(0.9, 0.91, movement);
                        float center = center_line_mask * dashes; float markings = max(side, center);
                        float grid = markings * p_fade * uGlow; gl_FragColor = vec4(uColor * grid, grid);
                    }`, transparent: true, blending: THREE.AdditiveBlending }); road = new THREE.Mesh(new THREE.PlaneGeometry(30, PALM_RANGE * 2), roadGridMat); road.rotation.x = -Math.PI / 2; road.position.y = 0.01; scene.add(road); }
        function createCar() { car = new THREE.Group(); scene.add(car); car.interiorPeakGlow = 0; car.cabinHue = 0; const carMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.9, roughness: 0.4 }); const chassisGeo = new THREE.BoxGeometry(1.6, 0.4, 3.8); const carBody = new THREE.Mesh(chassisGeo, carMat); carBody.position.y = 0.2; car.add(carBody); car.interiorGlowMaterial = new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 0 }); const glassMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.4, side: THREE.DoubleSide }); const cabin = new THREE.Group(); const cabinWidth = 1.2, cabinHeight = 0.6, cabinLength = 1.5; const roofHeight = 0.1, pillarWidth = 0.1; const roofGeo = new THREE.BoxGeometry(cabinWidth, roofHeight, cabinLength); const roof = new THREE.Mesh(roofGeo, carMat); roof.position.y = cabinHeight - roofHeight/2; const pillarGeo = new THREE.BoxGeometry(pillarWidth, cabinHeight, pillarWidth); const pillarFL = new THREE.Mesh(pillarGeo, carMat); pillarFL.position.set(-cabinWidth/2 + pillarWidth/2, cabinHeight/2, -cabinLength/2 + pillarWidth/2); const pillarFR = pillarFL.clone(); pillarFR.position.x *= -1; const pillarBL = pillarFL.clone(); pillarBL.position.z *= -1; const pillarBR = pillarFR.clone(); pillarBR.position.z *= -1; const pillarCL = pillarFL.clone(); pillarCL.position.z = 0; const pillarCR = pillarFR.clone(); pillarCR.position.z = 0; const interiorGlow = new THREE.Mesh( new THREE.BoxGeometry(cabinWidth - pillarWidth*2 - 0.05, cabinHeight - roofHeight - 0.05, cabinLength - pillarWidth*2 - 0.05), car.interiorGlowMaterial ); interiorGlow.position.y = (cabinHeight - roofHeight) / 2; cabin.add(roof, pillarFL, pillarFR, pillarBL, pillarBR, pillarCL, pillarCR, interiorGlow); cabin.position.set(0, 0.4, 0.5); car.add(cabin); const windshield = new THREE.Mesh(new THREE.PlaneGeometry(cabinWidth - pillarWidth, cabinHeight - roofHeight), glassMaterial); windshield.position.set(0, cabin.position.y + (cabinHeight-roofHeight)/2, cabin.position.z - cabinLength/2); car.add(windshield); const rearWindow = windshield.clone(); rearWindow.position.z = cabin.position.z + cabinLength/2; car.add(rearWindow); const sideWindowWidth = (cabinLength / 2) - pillarWidth * 1.5; const sideWindowGeo = new THREE.PlaneGeometry(sideWindowWidth, cabinHeight - roofHeight); const sideWindowFL = new THREE.Mesh(sideWindowGeo, glassMaterial); sideWindowFL.rotation.y = Math.PI/2; sideWindowFL.position.set(-cabinWidth/2, windshield.position.y, cabin.position.z - cabinLength/4); const sideWindowRL = sideWindowFL.clone(); sideWindowRL.position.z = cabin.position.z + cabinLength/4; const sideWindowFR = sideWindowFL.clone(); sideWindowFR.position.x *= -1; const sideWindowRR = sideWindowRL.clone(); sideWindowRR.position.x *= -1; car.add(sideWindowFL, sideWindowRL, sideWindowFR, sideWindowRR); const wheelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 24); const wheelMat = new THREE.MeshStandardMaterial({ color: 0x080808, roughness: 0.9 }); const createWheel = (x, z) => { const w = new THREE.Mesh(wheelGeo, wheelMat); w.rotation.z = Math.PI / 2; w.position.set(x, 0, z); return w; }; car.add(createWheel(-0.8, -1.6), createWheel(0.8, -1.6), createWheel(-0.7, 1.6), createWheel(0.7, 1.6)); const rearZ = 1.91; car.taillightL = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.15), new THREE.MeshBasicMaterial({ color: 0xff0000 })); car.taillightR = car.taillightL.clone(); car.taillightL.position.set(-0.4, 0.3, rearZ); car.taillightR.position.set(0.4, 0.3, rearZ); car.add(car.taillightL, car.taillightR); const signalMat = new THREE.MeshStandardMaterial({ color: 0xff8c00, emissive: 0xff8c00, emissiveIntensity: 0}); const signalGeo = new THREE.PlaneGeometry(0.2, 0.08); car.turnSignalL = new THREE.Mesh(signalGeo, signalMat.clone()); car.turnSignalR = new THREE.Mesh(signalGeo, signalMat.clone()); car.turnSignalL.position.set(-0.7, 0.3, rearZ); car.turnSignalR.position.set(0.7, 0.3, rearZ); car.add(car.turnSignalL, car.turnSignalR); car.headlightLensMaterialL = new THREE.MeshBasicMaterial({ color: 0xffffee, emissive: 0xffffee, emissiveIntensity: 0 }); car.headlightLensMaterialR = car.headlightLensMaterialL.clone(); const lensGeo = new THREE.CircleGeometry(0.15, 16); const lensL = new THREE.Mesh(lensGeo, car.headlightLensMaterialL); const lensR = new THREE.Mesh(lensGeo, car.headlightLensMaterialR); const headlightY = 0.3; const headlightZ = -1.901; lensL.position.set(-0.5, headlightY, headlightZ); lensR.position.set(0.5, headlightY, headlightZ); car.add(lensL, lensR); const createHeadlight = (side, lensMesh) => { const light = new THREE.SpotLight(0xffffee, 0, 80, Math.PI/7, 0.5, 2); light.position.copy(lensMesh.position); const target = new THREE.Object3D(); target.position.set(side * 1.5, 0, -20); light.target = target; car.add(target); return light; }
        car.headlightL = createHeadlight(-1, lensL); car.headlightR = createHeadlight(1, lensR); car.add(car.headlightL, car.headlightR); const beamMat = new THREE.ShaderMaterial({ uniforms: { uColor: { value: new THREE.Color(0xffffee) }, uOpacity: { value: 0.0 } }, vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`, fragmentShader: `uniform vec3 uColor; uniform float uOpacity; varying vec2 vUv; void main() { float r = 1.0 - pow(distance(vUv, vec2(0.5, 0.5)) * 2.0, 4.0); float l = pow(1.0 - vUv.y, 3.0); gl_FragColor = vec4(uColor, r * l * uOpacity); }`, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }); const beamHeight = 15; const beamGeo = new THREE.CylinderGeometry(0.1, 2.0, beamHeight, 16, 1, true); car.headlightBeamL = new THREE.Mesh(beamGeo, beamMat.clone()); car.headlightBeamR = new THREE.Mesh(beamGeo, beamMat.clone()); car.headlightBeamL.rotation.x = Math.PI / 2; car.headlightBeamR.rotation.x = Math.PI / 2; const beamZ = headlightZ - (beamHeight / 2); car.headlightBeamL.position.set(lensL.position.x, lensL.position.y, beamZ); car.headlightBeamR.position.set(lensR.position.x, lensR.position.y, beamZ); car.add(car.headlightBeamL, car.headlightBeamR); const spoilerBladeGeo = new THREE.BoxGeometry(1.4, 0.05, 0.2); const spoilerBlade = new THREE.Mesh(spoilerBladeGeo, carMat); spoilerBlade.position.set(0, carBody.position.y + 0.2 + 0.1, 1.7); spoilerBlade.rotation.x = -0.1; const spoilerSupportGeo = new THREE.BoxGeometry(0.05, 0.1, 0.05); const spoilerSupportL = new THREE.Mesh(spoilerSupportGeo, carMat); spoilerSupportL.position.set(-0.5, spoilerBlade.position.y - 0.05, spoilerBlade.position.z); const spoilerSupportR = spoilerSupportL.clone(); spoilerSupportR.position.x *= -1; car.add(spoilerBlade, spoilerSupportL, spoilerSupportR); const exhaustMat = new THREE.MeshStandardMaterial({color: 0xcccccc, metalness: 0.9, roughness: 0.2}); const exhaustGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.1, 12); exhaustGeo.rotateX(Math.PI / 2); const pipeY = 0.05; const pipeZ = rearZ + 0.05; const pipeSpacing = 0.1; const exhaustL1 = new THREE.Mesh(exhaustGeo, exhaustMat); exhaustL1.position.set(-0.4 - pipeSpacing/2, pipeY, pipeZ); const exhaustL2 = exhaustL1.clone(); exhaustL2.position.x += pipeSpacing; const exhaustR1 = exhaustL1.clone(); exhaustR1.position.x *= -1; const exhaustR2 = exhaustL2.clone(); exhaustR2.position.x *= -1; car.add(exhaustL1, exhaustL2, exhaustR1, exhaustR2); car.position.set(targetLaneX, 0.3, 3); }
        function prepareSceneryMaterials() { const baseVertexShader = `varying vec3 vPosition; void main() { vPosition = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`; const baseFragmentShader = `
                uniform float uTime; uniform float uAudioValue; uniform vec3 uColor1; uniform vec3 uColor2; varying vec3 vPosition;
                void main() {
                    vec3 baseColor = vec3(0.05, 0.0, 0.1);
                    float grid = (1.0 - step(0.95, fract(vPosition.x * 2.0))) * (1.0 - step(0.95, fract(vPosition.y * 1.0)));
                    float timeWave = sin(uTime * 0.5 + vPosition.y * 0.5);
                    vec3 windowColor = mix(uColor1, uColor2, timeWave);
                    float emissiveIntensity = pow(uAudioValue, 2.5) * 5.0;
                    vec3 finalColor = baseColor + windowColor * grid * emissiveIntensity;
                    gl_FragColor = vec4(finalColor, 1.0);
                }`; houseMaterials[0] = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0.0 }, uAudioValue: { value: 0.0 }, uColor1: { value: new THREE.Color(0x6a00ff) }, uColor2: { value: new THREE.Color(0xff0055) } }, vertexShader: baseVertexShader, fragmentShader: baseFragmentShader, side: THREE.DoubleSide }); houseMaterials[1] = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0.0 }, uAudioValue: { value: 0.0 }, uColor1: { value: new THREE.Color(0xff00ff) }, uColor2: { value: new THREE.Color(0x00ffff) } }, vertexShader: baseVertexShader, fragmentShader: baseFragmentShader, side: THREE.DoubleSide }); houseMaterials[2] = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0.0 }, uAudioValue: { value: 0.0 }, uColor1: { value: new THREE.Color(0xffaa00) }, uColor2: { value: new THREE.Color(0xffee00) } }, vertexShader: baseVertexShader, fragmentShader: baseFragmentShader, side: THREE.DoubleSide }); cactusMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, blending: THREE.AdditiveBlending }); }
        function createRoadsideScenery() { sceneryGroup = new THREE.Group(); scene.add(sceneryGroup); const sceneryPerSide = SCENERY_OBJECT_COUNT / 2; const zoneLength = PALM_RANGE / sceneryPerSide; for (let i = 0; i < sceneryPerSide; i++) { for (const side of [-1, 1]) { const zPos = -i * zoneLength - Math.random() * zoneLength; const xPos = (20 + Math.random() * 10) * side; if (Math.random() < 0.7) { if (Math.random() > 0.4) { const h = Math.random() * 20 + 10; const w = Math.random() * 4 + 2; const d = Math.random() * 4 + 2; const houseGeo = new THREE.BoxGeometry(w, h, d); const matIndex = Math.floor(Math.random() * houseMaterials.length); const house = new THREE.Mesh(houseGeo, houseMaterials[matIndex]); house.userData.type = matIndex; house.position.set(xPos, h / 2, zPos); sceneryGroup.add(house); } else { const cactus = new THREE.Group(); const trunk = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 0.5), cactusMaterial); const arm1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 2, 0.4), cactusMaterial); arm1.position.set(0, 0.5, 0); arm1.rotation.z = -Math.PI / 4; const arm2 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 2, 0.4), cactusMaterial); arm2.position.set(0, 0.5, 0); arm2.rotation.z = Math.PI / 4; cactus.add(trunk, arm1, arm2); cactus.position.set(xPos, 2, zPos); sceneryGroup.add(cactus); } } } } }
        function createMountains() { mountainGroup = new THREE.Group(); scene.add(mountainGroup); const mountainMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true }); const mountainHeight = 80; const geo = new THREE.PlaneGeometry(PALM_RANGE, mountainHeight, MOUNTAIN_W_SEGMENTS, MOUNTAIN_H_SEGMENTS); const mountainL = new THREE.Mesh(geo, mountainMat); mountainL.rotation.y = Math.PI/2; mountainL.position.set(-45, 0, -PALM_RANGE/2); const mountainR = new THREE.Mesh(geo.clone(), mountainMat); mountainR.rotation.y = -Math.PI/2; mountainR.position.set(45, 0, -PALM_RANGE/2); mountainGroup.add(mountainL, mountainR); }
        function createPalmTexture() { const c=document.createElement('canvas');const s=128;c.width=s;c.height=s;const x=c.getContext('2d');x.fillStyle='#050505';const t=s*0.06;x.beginPath();x.moveTo(s/2-t/2,s);x.quadraticCurveTo(s/2,s*0.7,s/2,s*0.25);x.quadraticCurveTo(s/2,s*0.7,s/2+t/2,s);x.fill();const X=s/2,Y=s*0.3,f=7,l=s*0.45;x.lineWidth=5;x.strokeStyle='#050505';for(let i=0;i<f;i++){const a=(i/(f-1))*Math.PI*1.3-(Math.PI*0.15);const eX=X+Math.cos(a)*l;const eY=Y-Math.sin(a)*l;const cX=X+Math.cos(a)*l*0.5;const cY=Y-Math.sin(a)*l*0.5-l*0.25;x.beginPath();x.moveTo(X,Y);x.quadraticCurveTo(cX,cY,eX,eY);x.stroke();}return new THREE.CanvasTexture(c); }
        function createProceduralPalms() { palmGroup = new THREE.Group(); scene.add(palmGroup); const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 }); const leafMaterialCyan = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0, roughness: 0.5 }); const leafMaterialMagenta = new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 0, roughness: 0.5 }); const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.15, 5, 6); const leafGeometry = new THREE.IcosahedronGeometry(1.8, 0); const palmTexture = createPalmTexture(); const darkSpriteMaterial = new THREE.SpriteMaterial({ map: palmTexture, fog: false }); const glowingSpriteMaterialMagenta = new THREE.SpriteMaterial({ color: 0xff00ff, map: palmTexture, fog: false, blending: THREE.AdditiveBlending }); const glowingSpriteMaterialCyan = new THREE.SpriteMaterial({ color: 0x00ffff, map: palmTexture, fog: false, blending: THREE.AdditiveBlending }); const palmsPerSide = PALM_COUNT / 2; const zoneLength = PALM_RANGE / palmsPerSide; for (let i = 0; i < palmsPerSide; i++) { for (const side of [-1, 1]) { const palmType = Math.random(); const zPos = -i * zoneLength - Math.random() * zoneLength; const xPos = 14 * side; if (palmType < 0.25) { const palm = new THREE.Group(); const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial); const chosenLeafMaterial = Math.random() > 0.5 ? leafMaterialCyan.clone() : leafMaterialMagenta.clone(); const leaves = new THREE.Mesh(leafGeometry, chosenLeafMaterial); leaves.position.y = 2.5; palm.add(trunk, leaves); palm.position.set(xPos, 2.5, zPos); palm.rotation.y = Math.random() * Math.PI; palmGroup.add(palm); } else if (palmType < 0.45) { const chosenSpriteMaterial = Math.random() > 0.5 ? glowingSpriteMaterialMagenta.clone() : glowingSpriteMaterialCyan.clone(); const palmSprite = new THREE.Sprite(chosenSpriteMaterial); palmSprite.position.set(xPos, 4, zPos); palmSprite.scale.set(12, 12, 12); palmGroup.add(palmSprite); } else { const palmSprite = new THREE.Sprite(darkSpriteMaterial.clone()); palmSprite.position.set(xPos, 4, zPos); palmSprite.scale.set(12, 12, 12); palmGroup.add(palmSprite); } } } }
        function createSun() { const sunTexture = (() => { const c=document.createElement('canvas');const s=256;c.width=s;c.height=s;const x=c.getContext('2d');x.beginPath();x.arc(s/2,s/2,s/2,0,Math.PI*2);x.save();x.clip();const g=x.createLinearGradient(0,0,0,s);g.addColorStop(0,'#ffee00');g.addColorStop(1,'#ff5e00');x.fillStyle=g;x.fill();x.fillStyle='#01000a';const C=10;for(let i=1;i<C;i+=2){const y=(s*0.45)+(i*(s*0.55/C));const h=s*0.04;x.fillRect(0,y,s,h);}x.restore();return new THREE.CanvasTexture(c);})(); const sunMat = new THREE.MeshBasicMaterial({ map: sunTexture, blending: THREE.AdditiveBlending, transparent: true, depthTest: false }); sun = new THREE.Mesh(new THREE.PlaneGeometry(35, 35), sunMat); sun.position.set(0, 25, -250); sun.renderOrder = -1; scene.add(sun); const sunGlow = new THREE.PointLight(0xff8c00, 3, 300, 2); sunGlow.position.copy(sun.position); scene.add(sunGlow); }
        function updateMountain(mesh,data,reversed){const v=mesh.geometry.vertices;const dL=data.length;const h=(clock.getElapsedTime()*0.02)%1;mesh.material.color.setHSL(h,0.5+data[2]/255*0.5,0.5+data[20]/255*0.3);for(let i=0;i<=MOUNTAIN_W_SEGMENTS;i++){const dI=Math.floor(i/MOUNTAIN_W_SEGMENTS*(dL/2-1));const aV=data[reversed?(dL/2-1)-dI:dI]/255.0;let f;if(reversed){f=Math.pow(i/MOUNTAIN_W_SEGMENTS,1.5);}else{f=Math.pow(1.0-(i/MOUNTAIN_W_SEGMENTS),1.5);}for(let j=0;j<=MOUNTAIN_H_SEGMENTS;j++){const vI=j*(MOUNTAIN_W_SEGMENTS+1)+i;if(!v[vI])continue;const pF=Math.pow(j/MOUNTAIN_H_SEGMENTS,2.5);const tY=(j>0)?aV*Viz.mountainHeight*pF*f:0;v[vI].y+=(tY-v[vI].y)*0.1;}}mesh.geometry.verticesNeedUpdate=true;}
        function animate() { requestAnimationFrame(animate); const delta = clock.getDelta(); const elapsed = clock.getElapsedTime(); currentSpeed = THREE.Math.lerp(currentSpeed, targetSpeed, delta * 1.0); if (vizInitialized) visualize(delta, elapsed); road.material.uniforms.uTime.value = elapsed; road.material.uniforms.uSpeed.value = currentSpeed; const targetZOffset = boostState === 'boosting' ? -Viz.boostCarOffset : 0; carZOffset = THREE.Math.lerp(carZOffset, targetZOffset, delta * 3.0); car.position.z = 3 + carZOffset; car.position.y = 0.3 + Math.sin(elapsed * 4) * Viz.carBob; car.position.x = THREE.Math.lerp(car.position.x, targetLaneX, delta * Viz.laneChangeSpeed); const targetRotationZ = (car.position.x - targetLaneX) * -0.08; car.rotation.z = THREE.Math.lerp(car.rotation.z, targetRotationZ, delta * 5); [palmGroup, sceneryGroup].forEach(g => { if (g) { g.children.forEach(p => { p.position.z += currentSpeed * delta; if (p.position.z > camera.position.z + 20) p.position.z -= (PALM_RANGE + 40); }); } }); controls.update(); composer.render(); }
        function visualize(delta, elapsed) { if (!analyserL || !analyserR) return; analyserL.getByteFrequencyData(frequencyDataL);analyserR.getByteFrequencyData(frequencyDataR); const bassL=(frequencyDataL[1]+frequencyDataL[2]+frequencyDataL[3])/3/255;const bassR=(frequencyDataR[1]+frequencyDataR[2]+frequencyDataR[3])/3/255;const bass=(bassL+bassR)/2; const midsL=(frequencyDataL[20]+frequencyDataL[25]+frequencyDataL[40])/3/255;const midsR=(frequencyDataR[20]+frequencyDataR[25]+frequencyDataR[40])/3/255;const mids=(midsL+midsR)/2; const highs=((frequencyDataL[60]+frequencyDataL[80]+frequencyDataL[100])/3+(frequencyDataR[60]+frequencyDataR[80]+frequencyDataR[100])/3)/2/255; const overall=(frequencyDataL.reduce((a,b)=>a+b)+frequencyDataR.reduce((a,b)=>a+b))/(frequencyDataL.length+frequencyDataR.length)/255; const bassAttack=bass-lastBass; energyBuffer.push(overall); if (energyBuffer.length > ENERGY_BUFFER_SIZE) { energyBuffer.shift(); } const smoothedOverallEnergy = energyBuffer.reduce((a, b) => a + b, 0) / energyBuffer.length; adaptiveBaseSpeed = Viz.minSpeed + (smoothedOverallEnergy * Viz.speedReactivity); bassBuffer.push(bass); if (bassBuffer.length > BASS_BUFFER_SIZE) { bassBuffer.shift(); } const averageBass = bassBuffer.reduce((a, b) => a + b, 0) / bassBuffer.length; if (bass > Viz.bassSustainThreshold && averageBass > (Viz.bassSustainThreshold * 0.8)) { boostEnergy += delta * (bass - Viz.bassSustainThreshold); } boostEnergy = Math.max(0, boostEnergy - Viz.energyDecayRate * delta); if (boostState === 'normal') { targetSpeed = adaptiveBaseSpeed; if (boostEnergy > Viz.boostThreshold) { boostState = 'boosting'; stateTimer = elapsed + Viz.boostDuration; boostEnergy = 0; } } else if (boostState === 'boosting') { targetSpeed = adaptiveBaseSpeed * Viz.boostMultiplier; if (elapsed > stateTimer) { boostState = 'cooldown'; stateTimer = elapsed + Viz.cooldownDuration; } } else if (boostState === 'cooldown') { targetSpeed = adaptiveBaseSpeed * 0.6; if (elapsed > stateTimer) { boostState = 'normal'; } } if (boostState === 'cooldown') { let targetColor = new THREE.Color().setRGB(Viz.brakeLightIntensity, 0, 0); if (bassAttack > 0.04) { targetColor.setRGB(25, 0.1, 0.1); } car.taillightL.material.color.lerp(targetColor, 0.5); car.taillightR.material.color.lerp(targetColor, 0.5); } else { let targetColor = new THREE.Color(0.8, 0, 0); if (bassAttack > 0.05) { targetColor.setRGB(10, 0.1, 0.1); } car.taillightL.material.color.lerp(targetColor, 0.1); car.taillightR.material.color.lerp(targetColor, 0.1); } sun.scale.setScalar(1+bass*Viz.sunPulse);road.material.uniforms.uGlow.value=0.8+overall*1.5; if(stars){stars.material.opacity=0.2+overall*0.8;stars.material.size=0.4+overall*0.3;} if (bassAttack > 0.05) { car.interiorPeakGlow = 18.0 * Viz.interiorGlowMultiplier; car.cabinHue = (car.cabinHue + 0.07) % 1; } car.interiorPeakGlow = THREE.Math.lerp(car.interiorPeakGlow, 0, 0.15); const baseGlow = (bass * 1.5) * Viz.interiorGlowMultiplier; car.interiorGlowMaterial.emissiveIntensity = baseGlow + car.interiorPeakGlow; car.interiorGlowMaterial.emissive.setHSL(car.cabinHue, 0.9, 0.5); car.interiorGlowMaterial.color.setHSL(car.cabinHue, 0.9, 0.5); const hL=midsL*Viz.headlightIntensity;const hR=midsR*Viz.headlightIntensity; car.headlightL.intensity=hL;car.headlightR.intensity=hR; car.headlightLensMaterialL.emissiveIntensity=hL*0.2;car.headlightLensMaterialR.emissiveIntensity=hR*0.2; car.headlightBeamL.material.uniforms.uOpacity.value=Math.min(0.5,hL*0.1); car.headlightBeamR.material.uniforms.uOpacity.value=Math.min(0.5,hR*0.1); if(bassAttack>Viz.laneChangeThreshold && !isBlinking){ let c=LANE_POSITIONS.indexOf(targetLaneX);let n=c; while(n===c){n=Math.floor(Math.random()*LANE_POSITIONS.length);} targetLaneX=LANE_POSITIONS[n]; isBlinking=true; blinkTimer=elapsed+1.0; } if(isBlinking){ const b = Math.sin(elapsed * 20) > 0; car.turnSignalL.material.emissiveIntensity = 0.0; car.turnSignalR.material.emissiveIntensity = 0.0; if (targetLaneX < car.position.x) { car.turnSignalL.material.emissiveIntensity = b ? 8.0 : 0.0; } else { car.turnSignalR.material.emissiveIntensity = b ? 8.0 : 0.0; } if(elapsed > blinkTimer){ isBlinking = false; } } else { car.turnSignalL.material.emissiveIntensity = 0.0; car.turnSignalR.material.emissiveIntensity = 0.0; } if(sceneryGroup){sceneryGroup.children.forEach(o=>{if(o.isMesh&&o.material.isShaderMaterial){o.material.uniforms.uTime.value=elapsed;switch(o.userData.type){case 0:o.material.uniforms.uAudioValue.value=bass;break;case 1:o.material.uniforms.uAudioValue.value=mids;break;case 2:o.material.uniforms.uAudioValue.value=highs;break;}}});} updateMountain(mountainGroup.children[0],frequencyDataL,false);updateMountain(mountainGroup.children[1],frequencyDataR,true); palmGroup.children.forEach(p=>{if(p.isGroup){const l=p.children[1];if(l&&l.material){l.material.emissiveIntensity=mids*Viz.palmGlow;}}}); lastBass=bass; }
        function onWindowResize(){camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);composer.setSize(window.innerWidth,window.innerHeight);}
        
        window.addEventListener('message', (event) => {
            if (event.data.type === 'START_AUDIO') {
                if (event.data.source === 'microphone') {
                    navigator.mediaDevices.getUserMedia({ 
                        audio: { deviceId: event.data.deviceId }, 
                        video: false 
                    }).then(stream => {
                        if (activeStream) { activeStream.getTracks().forEach(track => track.stop()); }
                        activeStream = stream;
                        startVisualization(stream);
                    }).catch(err => {
                        console.error("Не удалось запустить визуализацию:", err);
                        alert(`Ошибка: ${err.message}. Убедитесь, что вы предоставили все необходимые разрешения.`);
                    });
                } else if (event.data.source === 'system') {
                    navigator.mediaDevices.getDisplayMedia({ 
                        video: true, 
                        audio: true 
                    }).then(stream => {
                        if (activeStream) { activeStream.getTracks().forEach(track => track.stop()); }
                        activeStream = stream;
                        startVisualization(stream);
                    }).catch(err => {
                        console.error("Не удалось запустить визуализацию:", err);
                        alert(`Ошибка: ${err.message}. Убедитесь, что вы предоставили все необходимые разрешения.`);
                    });
                }
            }
        });

        function startVisualization(stream) {
            if (vizInitialized) return;
            if (!stream || stream.getAudioTracks().length === 0) {
                alert("Аудиопоток не получен. Убедитесь, что вы поставили галочку 'Поделиться звуком'.");
                stream?.getVideoTracks().forEach(t => t.stop());
                return;
            }

            const audioCtx = new(window.AudioContext || window.webkitAudioContext)();
            const source = audioCtx.createMediaStreamSource(stream);
            const splitter = audioCtx.createChannelSplitter(2);
            source.connect(splitter);
            
            analyserL = audioCtx.createAnalyser();
            analyserL.fftSize = 256;
            splitter.connect(analyserL, 0);
            
            analyserR = audioCtx.createAnalyser();
            analyserR.fftSize = 256;
            splitter.connect(analyserR, 1);
            
            frequencyDataL = new Uint8Array(analyserL.frequencyBinCount);
            frequencyDataR = new Uint8Array(analyserR.frequencyBinCount);
            
            vizInitialized = true;
        }

        // Запуск
        init();
        window.addEventListener('resize', onWindowResize, false);
    </script>
</body>
</html>
